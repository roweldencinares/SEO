/**
 * NEXUS-Powered Indexation Control System
 *
 * Handles:
 * - Robots.txt generation with pattern-based rules
 * - Meta-noindex tag management for WordPress
 * - Canonical tag auto-correction
 * - Real-time validation and health checks
 */

import { nexusify } from './nexus/core.js';

// ============================================================================
// ROBOTS.TXT GENERATION
// ============================================================================

/**
 * Generate robots.txt with pattern-based rules
 */
const generateRobotsTxt = nexusify(
  async (config) => {
    const {
      sitemap = 'https://www.example.com/sitemap.xml',
      allowedPaths = ['/', '/services/', '/coaching/', '/resources/'],
      disallowedPaths = ['/admin/', '/wp-admin/', '/wp-includes/', '/cart/', '/checkout/'],
      crawlDelay = 1,
      customRules = []
    } = config;

    let robotsTxt = '# Robots.txt generated by NEXUS Indexation Control\n\n';

    // Google Bot
    robotsTxt += 'User-agent: Googlebot\n';
    allowedPaths.forEach(path => {
      robotsTxt += `Allow: ${path}\n`;
    });
    disallowedPaths.forEach(path => {
      robotsTxt += `Disallow: ${path}\n`;
    });
    robotsTxt += '\n';

    // Bing Bot
    robotsTxt += 'User-agent: Bingbot\n';
    allowedPaths.forEach(path => {
      robotsTxt += `Allow: ${path}\n`;
    });
    disallowedPaths.forEach(path => {
      robotsTxt += `Disallow: ${path}\n`;
    });
    robotsTxt += '\n';

    // All other bots
    robotsTxt += 'User-agent: *\n';
    robotsTxt += `Crawl-delay: ${crawlDelay}\n`;
    disallowedPaths.forEach(path => {
      robotsTxt += `Disallow: ${path}\n`;
    });
    robotsTxt += '\n';

    // Custom rules
    customRules.forEach(rule => {
      robotsTxt += `${rule}\n`;
    });

    // Sitemap
    robotsTxt += `\nSitemap: ${sitemap}\n`;

    return {
      content: robotsTxt,
      rules: {
        allowed: allowedPaths.length,
        disallowed: disallowedPaths.length,
        custom: customRules.length
      }
    };
  },
  {
    service: 'indexation-control',
    mode: 'STANDARD',
    cacheKey: 'robots-txt-config',
    cacheTTL: 3600 // 1 hour cache
  }
);

/**
 * Validate robots.txt syntax
 */
const validateRobotsTxt = nexusify(
  async (content) => {
    const issues = [];
    const lines = content.split('\n');

    // Check for sitemap
    if (!content.includes('Sitemap:')) {
      issues.push({
        severity: 'warning',
        message: 'No sitemap directive found'
      });
    }

    // Check for user-agent directives
    const hasUserAgent = lines.some(line => line.startsWith('User-agent:'));
    if (!hasUserAgent) {
      issues.push({
        severity: 'error',
        message: 'No User-agent directives found'
      });
    }

    // Check for common mistakes
    lines.forEach((line, index) => {
      if (line.includes('Disallow: /') && line.trim() === 'Disallow: /') {
        issues.push({
          severity: 'critical',
          line: index + 1,
          message: 'Blocks entire site from crawling'
        });
      }
    });

    return {
      valid: issues.filter(i => i.severity === 'error' || i.severity === 'critical').length === 0,
      issues,
      lineCount: lines.length
    };
  },
  {
    service: 'indexation-control',
    mode: 'LITE'
  }
);

// ============================================================================
// META-NOINDEX MANAGEMENT
// ============================================================================

/**
 * Generate meta-noindex rules for WordPress posts/pages
 */
const generateNoindexRules = nexusify(
  async (criteria) => {
    const {
      excludeCategories = ['drafts', 'private'],
      excludeTags = ['noindex', 'private'],
      excludePostTypes = ['draft', 'private'],
      customPatterns = []
    } = criteria;

    const rules = [];

    // Category-based rules
    excludeCategories.forEach(category => {
      rules.push({
        type: 'category',
        pattern: category,
        action: 'noindex,nofollow',
        reason: 'Excluded category'
      });
    });

    // Tag-based rules
    excludeTags.forEach(tag => {
      rules.push({
        type: 'tag',
        pattern: tag,
        action: 'noindex,nofollow',
        reason: 'Excluded tag'
      });
    });

    // Post type rules
    excludePostTypes.forEach(postType => {
      rules.push({
        type: 'post_type',
        pattern: postType,
        action: 'noindex,nofollow',
        reason: 'Excluded post type'
      });
    });

    // Custom patterns
    customPatterns.forEach(pattern => {
      rules.push({
        type: 'custom',
        pattern: pattern.pattern,
        action: pattern.action || 'noindex,follow',
        reason: pattern.reason || 'Custom rule'
      });
    });

    return {
      rules,
      total: rules.length
    };
  },
  {
    service: 'indexation-control',
    mode: 'STANDARD',
    cacheKey: 'noindex-rules',
    cacheTTL: 1800 // 30 min cache
  }
);

/**
 * Apply noindex tags to WordPress content via REST API
 */
const applyNoindexToWordPress = nexusify(
  async (params) => {
    const { wpApiUrl, wpAuth, postIds, action = 'noindex,nofollow' } = params;

    const results = [];

    for (const postId of postIds) {
      try {
        // Update post meta via WordPress REST API
        const response = await fetch(`${wpApiUrl}/wp/v2/posts/${postId}`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${wpAuth}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            meta: {
              _genesis_noindex: action.includes('noindex') ? '1' : '0',
              _genesis_nofollow: action.includes('nofollow') ? '1' : '0'
            }
          })
        });

        const data = await response.json();

        results.push({
          postId,
          success: response.ok,
          action,
          title: data.title?.rendered || 'Unknown'
        });
      } catch (error) {
        results.push({
          postId,
          success: false,
          error: error.message
        });
      }
    }

    return {
      results,
      successful: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length
    };
  },
  {
    service: 'indexation-control',
    mode: 'FULL'
  }
);

// ============================================================================
// CANONICAL TAG MANAGEMENT
// ============================================================================

/**
 * Detect canonical tag issues on a page
 */
const detectCanonicalIssues = nexusify(
  async (params) => {
    const url = typeof params === 'string' ? params : params.input || params.url;
    const issues = [];

    try {
      const response = await fetch(url);
      const html = await response.text();

      // Extract canonical tags
      const canonicalRegex = /<link[^>]+rel=["']canonical["'][^>]*>/gi;
      const canonicalMatches = html.match(canonicalRegex) || [];

      // Check for multiple canonical tags
      if (canonicalMatches.length > 1) {
        issues.push({
          severity: 'error',
          type: 'multiple_canonical',
          message: `Found ${canonicalMatches.length} canonical tags (should be 1)`,
          tags: canonicalMatches
        });
      }

      // Check for missing canonical
      if (canonicalMatches.length === 0) {
        issues.push({
          severity: 'warning',
          type: 'missing_canonical',
          message: 'No canonical tag found'
        });
      }

      // Extract canonical URL
      if (canonicalMatches.length === 1) {
        const hrefMatch = canonicalMatches[0].match(/href=["']([^"']+)["']/);
        const canonicalUrl = hrefMatch ? hrefMatch[1] : null;

        // Check if canonical points to itself
        const normalizedUrl = url.replace(/\/$/, '');
        const normalizedCanonical = canonicalUrl?.replace(/\/$/, '');

        if (canonicalUrl && normalizedCanonical !== normalizedUrl) {
          issues.push({
            severity: 'info',
            type: 'canonical_redirect',
            message: 'Canonical points to different URL',
            canonical: canonicalUrl,
            actual: url
          });
        }

        // Check for protocol mismatch
        if (canonicalUrl && url.startsWith('https://') && canonicalUrl.startsWith('http://')) {
          issues.push({
            severity: 'error',
            type: 'protocol_mismatch',
            message: 'Canonical uses HTTP while page uses HTTPS',
            canonical: canonicalUrl
          });
        }
      }

      // Extract canonical URL from the tag
      let canonicalUrl = null;
      if (canonicalMatches.length === 1) {
        const hrefMatch = canonicalMatches[0].match(/href=["']([^"']+)["']/);
        canonicalUrl = hrefMatch ? hrefMatch[1] : null;
      }

      return {
        url,
        issues,
        canonical: canonicalUrl,
        health: issues.filter(i => i.severity === 'error').length === 0 ? 'healthy' : 'unhealthy'
      };
    } catch (error) {
      return {
        url,
        issues: [{
          severity: 'error',
          type: 'fetch_failed',
          message: error.message
        }],
        health: 'unknown'
      };
    }
  },
  {
    service: 'indexation-control',
    mode: 'STANDARD',
    cacheKey: null // Don't cache, always check fresh
  }
);

/**
 * Auto-correct canonical tag issues via WordPress API
 */
const correctCanonicalTag = nexusify(
  async (params) => {
    const { wpApiUrl, wpAuth, postId, correctUrl } = params;

    try {
      const response = await fetch(`${wpApiUrl}/wp/v2/posts/${postId}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${wpAuth}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          meta: {
            _genesis_canonical_uri: correctUrl
          }
        })
      });

      const data = await response.json();

      return {
        success: response.ok,
        postId,
        correctedUrl: correctUrl,
        title: data.title?.rendered || 'Unknown'
      };
    } catch (error) {
      return {
        success: false,
        postId,
        error: error.message
      };
    }
  },
  {
    service: 'indexation-control',
    mode: 'FULL'
  }
);

// ============================================================================
// BATCH OPERATIONS
// ============================================================================

/**
 * Audit entire site for indexation issues
 */
const auditIndexation = nexusify(
  async (config) => {
    const {
      sitemapUrl = 'https://www.example.com/sitemap.xml',
      maxPages = 100
    } = config;

    // Fetch sitemap
    const sitemapResponse = await fetch(sitemapUrl);
    const sitemapXml = await sitemapResponse.text();

    // Extract URLs
    const urlMatches = sitemapXml.match(/<loc>([^<]+)<\/loc>/g) || [];
    const urls = urlMatches
      .map(match => match.replace(/<\/?loc>/g, ''))
      .slice(0, maxPages);

    // Check each URL for canonical issues
    const results = [];
    for (const url of urls) {
      const audit = await detectCanonicalIssues({ input: url });
      results.push(audit.data);
    }

    // Summary
    const healthyCount = results.filter(r => r.health === 'healthy').length;
    const unhealthyCount = results.filter(r => r.health === 'unhealthy').length;
    const unknownCount = results.filter(r => r.health === 'unknown').length;

    const allIssues = results.flatMap(r => r.issues);
    const criticalIssues = allIssues.filter(i => i.severity === 'error');
    const warnings = allIssues.filter(i => i.severity === 'warning');

    return {
      summary: {
        totalPages: results.length,
        healthy: healthyCount,
        unhealthy: unhealthyCount,
        unknown: unknownCount,
        criticalIssues: criticalIssues.length,
        warnings: warnings.length
      },
      pages: results,
      criticalIssues: criticalIssues.slice(0, 10), // Top 10
      timestamp: new Date().toISOString()
    };
  },
  {
    service: 'indexation-control',
    mode: 'FULL',
    cacheKey: 'indexation-audit',
    cacheTTL: 3600 // Cache for 1 hour
  }
);

// ============================================================================
// EXPORTS
// ============================================================================

export {
  generateRobotsTxt,
  validateRobotsTxt,
  generateNoindexRules,
  applyNoindexToWordPress,
  detectCanonicalIssues,
  correctCanonicalTag,
  auditIndexation
};

export default {
  generateRobotsTxt,
  validateRobotsTxt,
  generateNoindexRules,
  applyNoindexToWordPress,
  detectCanonicalIssues,
  correctCanonicalTag,
  auditIndexation
};
